% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Introduction to coding},
  pdfauthor={Brad Duthie},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Introduction to coding}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{HTML Version:
\url{https://stirlingcodingclub.github.io/coding_types/notes.html}}
\author{Brad Duthie}
\date{08 NOV 2023}

\begin{document}
\maketitle

\hypertarget{contents}{%
\section{Contents}\label{contents}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{intro}{Introduction: Objective of these notes}
\item
  \protect\hyperlink{contrast}{Contrasting interpreted versus compiled
  language}
\item
  \protect\hyperlink{Rcode}{More R code to help get started}
\end{itemize}

\hypertarget{introduction-objectives-of-these-notes}{%
\section{Introduction: Objectives of these
notes}\label{introduction-objectives-of-these-notes}}

The focus of the synchronous coding club meeting this week is on general
computing concepts. These notes will stray a bit from that focus because
I want to introduce some R code that I did not last week. Hence, these
notes will include two distinct topics. The first topic will be
contrasting coding and code performance in an interpreted language (R)
versus a compiled language (C). The second topic will be picking up
where we left off
\href{https://stirlingcodingclub.github.io/getting_started/notes.html}{last
week} with the introduction to R programming. My hope is that there will
be a bit of something for everyone in these notes, including novices to
coding and more advanced R users. If you are just getting started, then
it might make sense to skip the section
\protect\hyperlink{contrast}{contrasting interpreted versus compiled
language} and move right to where we left off last week with
\protect\hyperlink{Rcode}{more R code to help get started}.

\hypertarget{contrasting-interpreted-versus-compiled-language}{%
\section{Contrasting interpreted versus compiled
language}\label{contrasting-interpreted-versus-compiled-language}}

Almost all coding is done using source code; that is, code that can be
read and understood by a human. To actually run the code, we need to
convert the source code into a binary format (ones and zeroes) that can
be read by the computer. To do this conversion, we can either
\emph{compile} the code or \emph{interpret} it. Technically speaking,
any code \emph{could} be compiled or interpreted, but most programming
languages are associated with one or the other method.

When compiling code, the source code is translated beforehand into a
form that the computer can read more easily. Only after this translation
occurs is the code actually run, so the process of running code occurs
in two steps (compile, then run). The benefit of compiled code is that
it can generally run much faster (orders of magnitude faster); the cost
is that writing compiled code is slower, more laborious, and often more
frustrating. Code that takes me 2-5 minutes in an interpreted language
such as R could easily take 30-60 minutes in a compiled language such as
C. But if the compiled code can finish running in minutes or hours
rather than days to weeks, then it might be worth the hassle.

When running interpreted code, individual chunks of code are run bit by
bit through an interpreter. This interpreter breaks down the code and
executes it on the fly, so everything is done in one step (e.g., in R,
there is no compile then run -- you just run the code in the console
after you have written it). The cost of this method is that the
interpreted code can be much slower. The benefit is that the actual
process of writing code is generally faster and more intuitive. For many
tasks, speed is also not worry, so there is little if any downside to
avoiding the compiler.

In all types of code, binary instructions (compiled or interpreted) are
sent to the computer's Central Processing Unit (CPU). What the CPU does
with these instructions is actually quite limited; it can read and write
to memory, and do some basic arithmetic. All of the instructions that
you type in your source code essentially boil down to these tasks. The
memory (specifically, `random-access memory', or RAM) is separate from
the CPU; it holds data that can be read and changed. The data exist as
binary units (ones and zeroes), which are grouped in chunks of eight to
make one `byte'. In relatively `high level' programming languages (e.g.,
R, MATLAB, python), you can more or less avoid thinking about all of
this because the code is abstracted away from the nuts and bolts of the
computer hardware and the management of memory is done behind the
scenes. In more `low level' programming languages (e.g., C, FORTRAN,
COBOL), you will need to be explicit about how your code uses the
computer's memory.

Let's start by running a very simple script of code, first in an
interpreted language (R), and then in a compiled language (C). The code
we write will count from one to one billion, printing every 100
millionth number. Here is what the code looks like in R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{count\_to\_1\_billion }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
    \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000000000}\NormalTok{)\{}
        \ControlFlowTok{if}\NormalTok{(i }\SpecialCharTok{\%\%} \DecValTok{100000000} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)\{}
          \FunctionTok{print}\NormalTok{(i);}
\NormalTok{        \}  }
\NormalTok{    \}}
    \FunctionTok{return}\NormalTok{(}\StringTok{"Done!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You can also find the Rscript with the code above
\href{https://github.com/StirlingCodingClub/coding_types/blob/main/count_to_1_billion.R}{on
GitHub}. Note that the above code defines a function and includes a
\texttt{for} loop. We will get to what these are doing in a later
workshop, but for now, all that you need to do is highlight the code
above and run it in the console. This will define the function. To run
the function, you can then type the following line of code in the
console.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count\_to\_1\_billion}\NormalTok{();}
\end{Highlighting}
\end{Shaded}

Note, this might take a while! While you are waiting, you can create a
new script for the compiled version written in C. To do this, you can
either download
\href{https://github.com/StirlingCodingClub/coding_types/blob/main/count_to_1_billion.c}{this
file} from GitHub or create a new script in Rstudio and paste the
following code.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\# include}\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)\{}

    \DataTypeTok{long}\NormalTok{ i}\OperatorTok{;}

    \ControlFlowTok{for}\OperatorTok{(}\NormalTok{i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{1000000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
       \ControlFlowTok{if}\OperatorTok{(}\NormalTok{i }\OperatorTok{\%} \DecValTok{100000000} \OperatorTok{==} \DecValTok{0}\OperatorTok{)\{}
\NormalTok{           printf}\OperatorTok{(}\StringTok{"\%lu}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
       \OperatorTok{\}}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Once pasted, save the file as \texttt{count\_to\_1\_billion.c}. If you
get a box that pops up asking ``Are you sure you want to change the type
of the file so that it is no longer an R script?'', then click ``Yes''.
Note that you could have also pasted the code into a text editor such as
notepad or gedit instead of Rstudio (but \emph{not} in a word processor
such as MS Word).

Now we need to compile the code. How you do this depends on the
operating system that you use (Mac, Linux, or Windows). I will first
show how to compile and run for Mac and Linux, then how to compile and
run for Windows. On Mac or Linux, you need to first open a terminal. You
can do this by finding an external one on your computer (e.g., do a
search for `terminal', and one should be available), or by using the
`Terminal' tab right within Rstudio (see below).

\includegraphics{img/terminal_tab.png}

\hypertarget{more-r-code-to-help-get-started}{%
\section{More R code to help get
started}\label{more-r-code-to-help-get-started}}

\begin{verbatim}
read.csv
head
dim
dat[4, 6]; # First row, second column?
hist
summary
plot
cor.test
lm
t.test
aov
\end{verbatim}

\hypertarget{references}{%
\section{References}\label{references}}

\end{document}
